(function(o,t){typeof exports=="object"&&typeof module<"u"?t(exports,require("uuid")):typeof define=="function"&&define.amd?define(["exports","uuid"],t):(o=typeof globalThis<"u"?globalThis:o||self,t(o.ProxyAssistantSDK={},o.uuid))})(this,function(o,t){"use strict";const p={development:{API_BASE_URL:"http://localhost:8080"},ngrok:{API_BASE_URL:"https://2e26-2a00-23c8-16b2-8301-5494-7384-8ee5-ec42.ngrok-free.app"},production:{API_BASE_URL:"https://proxy-server-14953211771.europe-west2.run.app"}},u=process.env.NODE_ENV||"development";class S{constructor(){console.log(`NODE_ENV = ${process.env.NODE_ENV}`),this.apiBaseUrl=p[u].API_BASE_URL||null,this.endpoints={prompt:"/api/gemini/system-prompt",stt:"/api/stt",tts:"/api/tts",gemini:"/api/gemini",geminiHistory:"/api/gemini/history",voice:" "}}setApiBaseUrl(e){console.log(`Setting API base URL to: ${e}`),this.apiBaseUrl=e}getApiBaseUrl(){if(!this.apiBaseUrl)throw new Error("API base URL is not set. Please configure it before using the SDK.");return this.apiBaseUrl}getEndpoint(e){const s=this.getApiBaseUrl(),n=this.endpoints[e];if(!n)throw new Error(`Endpoint for service "${e}" is not defined.`);return`${s}${n}`}}const i=new S,m=30*60*1e3;class f{constructor(){this.sessionDataKey="sessionData"}_getSessionData(){const e=localStorage.getItem(this.sessionDataKey);if(!e)return null;try{const{sessionId:s,expiresAt:n}=JSON.parse(e);return new Date().getTime()>n?(localStorage.removeItem(this.sessionDataKey),null):{sessionId:s,expiresAt:n}}catch(s){return console.error("SessionManager: Failed to parse session data from localStorage:",s),localStorage.removeItem(this.sessionDataKey),null}}_setSessionData(e,s=m){const a=new Date().getTime()+s,v={sessionId:e,expiresAt:a};localStorage.setItem(this.sessionDataKey,JSON.stringify(v))}initializeSession(){const e=this._getSessionData();if(!e){const s=t.v4();return this._setSessionData(s),console.log("New session ID generated:",s),s}return console.log("Existing session ID restored:",e.sessionId),e.sessionId}getSessionId(){const e=this._getSessionData();if(!e)throw new Error("Session has not been initialized or has expired.");return e.sessionId}renewSession(){const e=t.v4();return this._setSessionData(e),console.log("Session ID renewed:",e),e}clearSession(){localStorage.removeItem(this.sessionDataKey),console.log("Session cleared.")}}const c=new f;class r{constructor(){if(r.instance)return r.instance;this.connection=null,this.isConnected=!1,this.messageQueue=[],this.messageHandlers=[],r.instance=this}connect(e){if(this.connection){console.warn(`WebSocketManager: Already connected to ${e}.`);return}this.connection=new WebSocket(e),this.connection.onopen=()=>{for(console.log(`WebSocketManager: Connection opened to ${e}.`),this.isConnected=!0;this.messageQueue.length>0;){const s=this.messageQueue.shift();this.sendMessage(s)}},this.connection.onmessage=s=>{const n=JSON.parse(s.data);this.messageHandlers.forEach(a=>a(n))},this.connection.onerror=s=>{console.error("WebSocketManager: Connection error:",s)},this.connection.onclose=()=>{console.log("WebSocketManager: Connection closed."),this.isConnected=!1,this.connection=null}}disconnect(){if(!this.connection){console.warn("WebSocketManager: No active connection to close.");return}this.connection.close(),this.connection=null,this.isConnected=!1}sendMessage(e){if(!this.isConnected||this.connection.readyState!==WebSocket.OPEN){console.log("WebSocketManager: Queueing message:",e),this.messageQueue.push(e);return}this.connection.send(JSON.stringify(e))}addMessageHandler(e){this.messageHandlers.push(e)}removeMessageHandler(e){this.messageHandlers=this.messageHandlers.filter(s=>s!==e),console.log("WebSocketManager: Message handler removed.")}}const y=new r;class d{constructor(){this.webSocketManager=y,this.endpoint=i.getEndpoint("voice"),this._messageHandler=null,this.connected=!1}connect(){if(this.connected){console.log("GeminiService: Already connected.");return}this.webSocketManager.connect(this.endpoint),this.connected=!0,this._messageHandler&&this.webSocketManager.removeMessageHandler(this._messageHandler),this._messageHandler=e=>{var s;e.action==="gemini"&&((s=e.payload)!=null&&s.agent)&&this.onGeminiResponse&&this.onGeminiResponse(e.payload.agent)},this.webSocketManager.addMessageHandler(this._messageHandler),console.log("GeminiService: Connected and handler added.")}disconnect(){this._messageHandler&&(this.webSocketManager.removeMessageHandler(this._messageHandler),this._messageHandler=null),this.webSocketManager.disconnect(this.endpoint),this.connected=!1,console.log("GeminiService: Disconnected from WebSocket.")}setResponseHandler(e){this.onGeminiResponse=e}async sendRestMessage(e,s){try{const n=await fetch(`${i.getApiBaseUrl()}/api/gemini`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sessionId:e,inputText:s})});return console.log(e,s),n.ok?(await n.json()).response||null:(console.error("Failed to send REST message to Gemini."),null)}catch(n){return console.error("Error sending REST message to Gemini:",n),null}}}const g={"Content-Type":"application/json",...process.env.NODE_ENV!=="production"&&{"ngrok-skip-browser-warning":"true"}};class h{static async fetchHistory(){const e=c.getSessionId();try{const s=await fetch(`${i.getApiBaseUrl()}/api/gemini/history?sessionId=${encodeURIComponent(e)}`,{method:"GET",headers:g});return s.ok?await s.json():(console.error("Failed to fetch conversation history."),[])}catch(s){return console.error("Error fetching conversation history:",s),[]}}static async clearHistory(){const e=c.getSessionId();try{await fetch(`${i.getApiBaseUrl()}/api/gemini/history?sessionId=${encodeURIComponent(e)}&clear=true`,{method:"GET",headers:g}),console.log("Conversation history cleared.")}catch(s){console.error("Error clearing conversation history:",s)}}}console.log(i,c,d,h);const w="test";o.Config=i,o.ConversationService=h,o.GeminiService=d,o.SessionManager=c,o.test=w,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
